/*
 Navicat Premium Data Transfer

 Source Server         : qiccc
 Source Server Type    : MySQL
 Source Server Version : 50744
 Source Host           : 82.156.158.155:3306
 Source Schema         : weblog

 Target Server Type    : MySQL
 Target Server Version : 50744
 File Encoding         : 65001

 Date: 09/11/2024 15:02:33
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for t_article
-- ----------------------------
DROP TABLE IF EXISTS `t_article`;
CREATE TABLE `t_article`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '文章id',
  `title` varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '文章标题',
  `cover` varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '文章封面',
  `summary` varchar(160) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '文章摘要',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '最后一次更新时间',
  `is_deleted` tinyint(2) NOT NULL DEFAULT 0 COMMENT '删除标志位：0：未删除 1：已删除',
  `read_num` int(11) UNSIGNED NOT NULL DEFAULT 1 COMMENT '被阅读次数',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_create_time`(`create_time`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 10 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_article
-- ----------------------------
INSERT INTO `t_article` VALUES (6, 'weblog介绍', 'https://qiccc-weblog.oss-cn-beijing.aliyuncs.com/img/loginjpg.jpg', '博客', '2024-11-01 16:07:12', '2024-11-04 19:40:00', 0, 15);
INSERT INTO `t_article` VALUES (7, 'Tailwind CSS 快速入门', 'https://qiccc-weblog.oss-cn-beijing.aliyuncs.com/img/2024/11/04/242873e40b7c44d185043359a3b55b36.png', 'Tailwind CSS 快速入门', '2024-11-04 19:43:53', '2024-11-04 19:46:00', 0, 1);
INSERT INTO `t_article` VALUES (8, 'Animate.css 简单归纳', 'https://qiccc-weblog.oss-cn-beijing.aliyuncs.com/img/2024/11/04/f639d39bd4264461a7a76cf846ae0fb6.png', '', '2024-11-04 19:50:51', '2024-11-04 19:50:51', 0, 1);
INSERT INTO `t_article` VALUES (9, 'Vue基本使用', 'https://qiccc-weblog.oss-cn-beijing.aliyuncs.com/img/2024/11/04/97839101b66e40b5b5d8f0cd1189c50a.png', '', '2024-11-04 19:53:00', '2024-11-04 19:53:00', 0, 2);

-- ----------------------------
-- Table structure for t_article_category_rel
-- ----------------------------
DROP TABLE IF EXISTS `t_article_category_rel`;
CREATE TABLE `t_article_category_rel`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `article_id` bigint(20) UNSIGNED NOT NULL COMMENT '文章id',
  `category_id` bigint(20) UNSIGNED NOT NULL COMMENT '分类id',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `uni_article_id`(`article_id`) USING BTREE,
  INDEX `idx_category_id`(`category_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 15 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章所属分类关联表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_article_category_rel
-- ----------------------------
INSERT INTO `t_article_category_rel` VALUES (10, 6, 8);
INSERT INTO `t_article_category_rel` VALUES (12, 7, 11);
INSERT INTO `t_article_category_rel` VALUES (13, 8, 11);
INSERT INTO `t_article_category_rel` VALUES (14, 9, 11);

-- ----------------------------
-- Table structure for t_article_content
-- ----------------------------
DROP TABLE IF EXISTS `t_article_content`;
CREATE TABLE `t_article_content`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '文章内容id',
  `article_id` bigint(20) NOT NULL COMMENT '文章id',
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '教程正文',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_article_id`(`article_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 10 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章内容表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_article_content
-- ----------------------------
INSERT INTO `t_article_content` VALUES (6, 6, '# `WebLog`博客网站\n\n## 项目介绍\n\n> ​	每个技术人都应该有属于自己的博客！相比较直接使用第三方博客平台，自行搭建博客更有成就感；没有平台限制,还有可以自由 `div` 定制自己想要的博客 `css` 样式.\n\n### 项目目标\n\n> 1. 掌握独立开发全栈项目的能力（*后端 + 前端*）；\n> 2. 掌握 `Spring Boot` 相关技术栈，以及构建后端项目能力，写出符合企业级的代码规范；\n> 3. 掌握 `Vue 3.x` + `Element Plus + Vite 4` 技术构建前端工程的能力，并能够手动搭建 `Admin` 后台管理系统；\n> 4. 掌握前端页面响应式设计（同时适配不同屏幕），排版布局，能够根据自己需求，`div` 自己想要的前端效果；\n> 5. 能够独立完成整个网站的部署流程，从本地功能开发，功能测试，再到部署到云服务器上、域名选购、网站备案，最终公网可访问；\n\n### 技术亮点\n\n> - 在技术选型上，选择了目前主流热门的技术栈，对标企业级项目开发；\n> - 严格把控代码质量，数据库设计，写出高效简介的代码；\n> - 熟悉后端工程的搭建，如一些通用的基础设施：参数校验、全局异常捕获、`API` 统一出入参日志打印等等；\n> - 能够独立完成整个网站的部署流程，从本地功能开发，功能测试，再到部署到云服务器上、域名选购、网站备案，最终公网可访问；\n> - 对象存储 `阿里云oos` 的使用, 能够独立搭建个人图床；\n> - 从 0 到 1 ，通过 `Element Plus` 纯手搭 `Admin` 管理后台前端骨架；\n\n### 结构插件介绍\n\n> 搭建 Spring Boot 多模块工程骨架:`weblog-springboot`为父模块,\n>\n> 1. `weblog-web` 模块，此模块是项目的入口，Maven 打包的打包插件放在这里，同时，和博客前台页面展示相关的功能也统一放在此模块下;\n> 2. `weblog-module-admin` 模块: 一个负责 `Admin` 管理后台功能的子模块，此模块用于统一放置和 `Admin` 管理后台相关的功能;\n> 3. `weblog-module-common` 模块:此模块专门用于存放一些通用的功能，如接口的日志切面、全局异常管理等等;\n> 4. `weblog-module-jwt`模块 : 此模块负责`admin`的身份认证和信息校验,博客前台可以被任何人访问,所以不对前台做身份校验;\n\n- 插件与基本工具类配置\n\n  1. `Lombok` 是一个超酷的 Java 库 : **避免编写那些冗余的 Java 样板式代码**，如对象中的 `get`、`set`、`toString` 等方法，解放双手，堪称偷懒神器;\n  2. `Logback` 是日志框架 SLF4J 的一个实现 : **日志可以帮助我们监控、调试和跟踪代码的运行情况**`Logback` 提供了更高的性能，更丰富的日志功能和更好的配置选项;\n  3. 使用jackson库对数据进行转换json格式处理,使响应数据更容易操作与阅读.\n  4. 自定义注解 : 实现 `API` 请求日志切面,可以为所有使用 `@ApiOperationLog` 注解的方法自动添加日志逻辑，而不需要在每个方法中手动添加\n  5. `MDC` 实现日志追踪功能 : ***为每个请求分配一个唯一的标识，并将该标识添加到每条日志消息中，从而方便地区分和跟踪每个请求的日志*;**\n  6. `JSR 380` 参数校验注解 : 该规范定义了一系列注解，用于验证 `Java Bean` 对象的属性，确保它们满足某些条件或限制。**使用注解来为实体类参数上方之间添加参数校验.**\n  7. 实现全局异常管理 : 在没有全局异常管理的情况下，每个控制器或 `service` 服务中可能都会有各种 `try-catch` 代码块来捕获和处理异常。避免**代码重复;不一致的响应格式;增加维护成本 ;可读性差;**\n  8. 整合 `Mybatis Plus` : **快速开发**：`MyBatis Plus` 提供了一系列的便捷功能，如自动生成 SQL 语句、通用 Mapper 等，使数据库操作更加高效，能够节省开发时间。**更少的配置**： Spring Boot 已经为我们提供了很多默认的配置，整合 MyBatis Plus 时只需少量的配置，减少了繁琐的配置步骤。\n  9. 整合p6spy 组件 : 一方面可以了解到每个操作都具体**执行的什么 `SQL` 语句**， 另一方面通过**打印执行耗时**，也可以提前发现一些慢 `SQL`，提前做好优化;\n  10. 整合 Spring Security : 作为 Spring 框架的一部分，Spring Security 提供了强大的功能，帮助开发人员实现**身份认证、授权、会话管理以及其他与安全**相关的任务。\n  11. 整合 `JWT` ：实现身份认证 : `JWT（JSON Web Token）`是一种用于在不同应用之间安全传输信息的开放标准（RFC 7519）。它是一种基于 JSON 的轻量级令牌，由三部分组成：头部（Header）、载荷（Payload）和签名（Signature）。JWT 被广泛用于实现身份验证和授权，**特别适用于前后端分离的应用程序**。当用户名、密码输入正确时，返回 Token 令牌，否则提示错误信息。\n  12. `JWT` ：实现接口鉴权 : 在现代的 Web 应用程序中，接口鉴权是一个重要的安全考虑因素。**通过接口鉴权，您可以确保只有经过身份验证和授权的用户能够访问特定的接口和资源。**我们通过 `Spring Security + JWT` 已经实现了用户认证功能，新增后端程序中拿到令牌，对接口进行鉴权，若令牌正确，则可正常访问接口资源，否则提示对应错误信息。\n  13. 阿里云`oos` : 存储图片上云\n  14. \n\n- 前端搭建整合组件和`css`库\n\n  1. 整合 `vue-router` 路由管理器 :  `Vue Router` 是 `Vue.js` 官方提供路由管理器。在一个标准的单页面应用中，**仅有一个 HTML 页面被服务器发送到客户端**。随后的页面内容都是通过 `JavaScript` 动态替换生成的。这时候，就需要 `Vue Router` 来管理这些页面的导航和组织。\n  2. Vite 配置路径别名 : `alias` 是一个用于定义路径别名的配置选项。当你的项目结构变得复杂时，**路径别名可以帮助你简化 `import` 或 `require` 语句中的路径**，让代码更干净、更可维护。\n  3. 整合 `Tailwind CSS` : `Tailwind CSS` 是一个高度可定制的、实用工具优先的 CSS 框架，它使你能够通过组合小型、单一用途的类来构建现代网站界面，**而无需写任何 CSS**。`Tailwind CSS` 在生产环境中会**自动移除未使用的样式，这有助于保持 CSS 文件大小最小**。\n  4. 组件库：`Flowbite` : `Flowbite` 是一个基于 `Tailwind CSS` 创建的组件库，旨在帮助开发者**快速构建现代、响应式的 Web 应用界面。**\n  5. Element Plus 组件库 : Element Plus 是一个专为 `Vue 3` 设计的 UI 组件库。它提供了一整套丰富且高质量的组件，从基本的按钮和输入框到复杂的日期选择器和数据表格。这些组件不仅样式美观，而且具有广泛的定制选项。**同时，它也是目前企业级 `Admin` 管理后台中，使用广度非常高的一个组件框架。**\n  6. `Animate.css` 添加入场动画 : `Animate.css` 是一个跨浏览器的 `CSS` 动画库，**提供了许多预设的、流畅的动画效果。用户只需添加几个 `CSS` 类名，就可以轻松实现复杂的动画效果**，无需编写任何 `JavaScript` 代码。\n  7. 整合 `Axios` 实现登录功能（解决跨域问题) : \n\n  ### 登录模块开发\n\n  1. #### 登录页设计：支持响应式布局 :\n\n     **基本布局** : 首先，我们通过 Tailwind 的 `grid` 网格布局，实现一个登录页面的基本骨架，分为左边栏和右边栏\n\n     1. 右边栏登录表单 : 引入了 Element Plus 表单组件 , 并添加了两个输入框和一个登录按钮,美化组件上方文字\n\n     2. ![image-20241023192612557](./assets/image-20241023192612557.png)\n\n     3. 左边栏登录设计  : 添加了一些描述性的文字，以及一张背景色透明的图片\n\n     4. ![image-20241023192635915](./assets/image-20241023192635915.png)\n\n        \n\n  2. ##### 通过 `Animate.css` 给登录页添加入场动画\n\n     1. 让页面过渡更加友好 : 添加弹跳动画 ,给右边栏的父级 `div` 添加 `bounceInRight`,同理给左边`div`添加向右弹跳动画.\n\n  3. ##### `p6spy` 组件打印完整的 SQL 语句、执行耗时\n\n     1. 一方面可以了解到每个操作都具体执行的什么 `SQL` 语句， 另一方面通过打印执行耗时，也可以提前发现一些慢 SQL\n     2. 添加`applcation-prod.yml`配置文件,区分开发环境和上线环境\n\n  4. ##### Spring Security 整合 `JWT` \n\n     1. **灵活性** : `JWT` 可以存储任意格式的数据，使其成为传递用户信息、权限、角色等的理想选择。\n     2. **安全性**：`JWT` 使用签名进行验证，确保信息在传输过程中不被篡改。\n     3. **`PasswordEncoder` 密码加密**  : 在系统中，安全存储用户密码是至关重要的。使用明文存储密码容易受到攻击，因此使用密码加密技术来保护用户密码是必不可少的。\n     4. **使用 `BCrypt` 算法对密码进行加密**。`BCrypt` 是一种安全且适合密码存储的哈希算法，它在进行哈希时会自动加入“盐”，增加密码的安全性。\n     5. **实现接口鉴权** : 通过 `Spring Security` + `JWT` 已经实现了用户认证功能，当用户名、密码输入正确时，返回 Token 令牌，否则提示错误信息。将在后端程序中拿到此令牌，对接口进行鉴权，若令牌正确，则可正常访问接口资源，否则提示对应错误信息。\n\n  5. ##### `Axios` 实现跨域问题\n\n     1. `Axios` 是一个流行的用于发起 `HTTP` 请求的 `JavaScript` 库。它可以在浏览器和 `Node.js` 环境中使用，提供了一种简洁且强大的方式来处理异步网络请求。\n     2. 整合 `Axios` 并调用登录接口，当登录成功后，跳转后台首页的功能就完成了.\n\n  6. ##### 登录页表单验证\n\n     1. 除了后端要校验外，前端也需要校验，并给予用户友好的提示信息。\n     2. `Element Plus` 提供的 Form 组件允许你验证用户的输入是否符合规范，来帮助你找到和纠正错误。只需为 `rules` 属性传入约定的验证规则，并将 `form-Item` 的 `prop` 属性设置为需要验证的特殊键值即可.![image-20241030152605943](./assets/image-20241030152605943.png)\n\n  7. ##### 回车键监听\n\n     1. **交互做的好一点** ,当输入完用户名、密码后，直接敲击回车键就能完成登录了。\n     2. 引入了 `onMounted` 、`onBeforeUnmount` 生命周期方法，然后在 `onMounted()` 方法中添加了键盘监听事件，当键盘的 `key` 值为 `Enter` 时，也就是回车键时，直接调用 `onSubmit()` 登录。然后在 `onBeforeUnmount()` 生命周期方法中，移除了键盘监听事件。\n\n  8. ##### 按钮加载\n\n     1. 当触发登录后，会调用后台接口，网络 IO 可能会消耗一点时间，为了给用户一个友好的提示，显示加载 Loading 非常有必要\n     2. Element Plus 提供的按钮组件提供了加载属性 `loading`, 通过设置为 `true` 或者 `false` 来决定是否要显示加载状态。上述代码中，声明了一个响应式的变量 `loading`, 在请求登录接口的开始，将其设置为了 `true`, 然后请求结束后，将其设置为 `false`, 恢复正常样式。\n\n     ![image-20241029152109497](./assets/image-20241029152109497.png)\n\n  9. ##### 存储 Token 到 Cookie 中\n\n     1. `Cookie`是一种用于在客户端和服务器之间传递信息的小型文本文件。它通常由服务器发送给用户的浏览器，然后浏览器将这些信息存储在用户的计算机上，以备将来的使用.\n     2. 使用`VueUse` 工具库简化js操作开发,其中`useCookies` 提供了一些 `API` ，用于操作 `Cookie`\n\n     ![image-20241029152309347](./assets/image-20241029152309347.png)\n\n  10. ##### 密码框显示明文小眼睛\n\n      1. 密码框输入密码，默认都是点点点这种密文形式，为了保护数据的安全性，不对用户可见的，\n      2. 但是，比较好的交互模式是，用户可手动设置密码可见\n      3. ![image-20241023200514424](./assets/image-20241023200514424.png)\n      4. `Element Plus` 提供的密码框组件默认提供了此功能，只需添加 `show-password` 属性即可得到一个可切换显示隐藏的密码框。\n\n  11. ##### 重复登录问题\n\n      1. 当用户成功登录后，再次访问登录页时，你会发现依然可以访问，这样就会导致用户*重复登录*的问题。*正确的逻辑应该是，当用户已经登录，则跳转后台首页*。\n      2. 在路由的前置守卫中,新添加了一个 `else if` 判断，单独对当 `Token` 令牌不为空，也就是用户已登录，且访问登录页的情况，提示用户*请勿重复登录*，并强制跳转到后台首页。\n\n      ![image-20241029152339646](./assets/image-20241029152339646.png)\n\n### `admin`模块开发\n\n1. #### 后台管理主布局分析\n\n   1. **左侧导航栏**：也是功能菜单栏，点击后，内容区域会展现不同的页面，如文章管理列表等；\n   2. **顶部栏**：通常用于显示用户是否登录、以及其它一些功能，如全屏展示、白天黑夜效果、语言国际化等；\n   3. **标签导航栏**：每次打开一个新的页面，标签导航栏内就会动态新增一个标签，点击标签可来回切换页面；\n   4. **内容区域**：根据当前路由动态渲染不同的内容页；\n   5. **Footer 页脚** ：展示一些页脚信息，如 `Copyright` 版权信息等。\n\n   ![image-20241029161718061](./assets/image-20241029161718061.png)\n\n2. ##### 填充`AdminHeader.vue` 组件的内容\n\n   1. **边距问题** : 头部左右有边距,通过 *`F12`* 审查元素，发现是 `Element Plus` 组件样式导致的 , 重写 `.el-header` 选择器，将 `padding` 设置为 0：\n   2. **分析布局**  : 如下，分为左侧点击收缩菜单栏图标，以及右侧用户头像下拉框、全屏图标![image-20241029162229630](./assets/image-20241029162229630.png)\n   3. **样式冲突** : 为了不让 `Element Plus` 内部的样式覆盖 `Tailwind CSS` 的样式，需要用一层 `<div>` 将包裹起来\n   4. **添加 `Tooltip` 文字提示** : 当鼠标移动到某个区域，也是是 `hover` 时的提示信息，Element Plus 提供了响应的组件以供使用 ![image-20241029162442541](./assets/image-20241029162442541.png)\n\n3. #### 填充 Menu 菜单栏\n\n   1. **布局分析** : 左侧栏的布局结构，分为两个部分：上面的 Logo 图片, 下面的菜单栏；![image-20241029162920223](./assets/image-20241029162920223.png)\n\n   2. **结构调整** : 使用**Element Plus Menu** 菜单组件,因为是博客系统，没有复杂的二级菜单、三级菜单，所以*只需保留一级菜单即可*。精简一下菜单代码;\n\n   3. **Logo 制作** : 制作了一张背景透明的 Logo 图片，格式为 `*PNG*`;![image-20241029164101564](./assets/image-20241029164101564.png)\n\n   4. **菜单栏数据** : 在 `<script>` 标签中定义个 `menus` 数组，包含以下属性：\n\n      - `name` : 菜单名称；\n\n      - `icon` : 菜单图标；\n      - `path` : 菜单对应的路由；\n\n   5. **路由跳转** : 点击不同的菜单，内容区域应该能渲染对应路由的页面, 为 `<el-menu>` 组件添加 `@select` 选择事件, 还需在 `/router/index.js` 中声明好对应的路由\n\n   6. **整合`Pinia`** : `Pinia` 是一个强大状态管理库，可以帮助更好地管理和组织应用程序的状态。通过创建 `store`，可以轻松地将状态逻辑封装在一个地方，然后在组件中使用它。\n\n   7. **左边菜单栏点击收缩、展开功能实现** : \n\n      - **添加 Icon 的点击事件** : 为 `AdminHeader` 组件中的收缩 `Icon` 添加点击事件\n      - **动态设置菜单栏的宽度** : 引入 `useMenuStore` , 有了它就可以拿到全局状态中的菜单宽度了。然后，为菜单最顶层的 `<div>` 容器绑定了动态样式 `:style=\"{ width: menuStore.menuWidth }\"` , 这样就可以响应式的设置菜单的 `CSS` 宽度值了;![image-20241029163953748](./assets/image-20241029163953748.png)![image-20241029164012380](./assets/image-20241029164012380.png)\n\n   8. **支持全屏展示** :`VueUse` 这个工具集合中就包含了这个功能库。引入核心包中的 `useFullscreen` ，然后拿到了它提供的 `isFullscreen` 变量，它被用于记录当前是否处于全屏；还有一个 `toggle` 方法![image-20241029164322026](./assets/image-20241029164322026.png)\n\n4. #### 标签导航栏组件实现\n\n   1. **布局分析** : 需要的是一个左右布局,\n\n      ①：左侧栏是标签导航栏；\n\n      ②：右侧是一个下拉菜单，鼠标悬浮其上，会弹出菜单，以供用户关闭标签页；![image-20241029164613191](./assets/image-20241029164613191.png)\n\n   2. **实现基本布局** : 使用 `Element Plus` 官方提供了 `Tabs` 标签页来实现\n\n   3. **收缩左侧菜单，标签导航栏未跟随** : 当我们点击收缩左侧菜单栏，标签栏由于设定了 `left: 250px` , 这个值是写死的;解决这个问题也比较简单，使用 `Pinia` 的全局状态;\n\n   4. **点击左侧栏菜单，无法动态添加 tab 标签页** : 引入了 `vue-router` 中的 `onBeforeRouteUpdate` 路由生命周期钩子，在 `onBeforeRouteUpdate` 路由生命周期钩子中，先是设置了需要被激活的 `tab` 标签，然后调用了 `addTab()` 方法来动态添加标签页。\n\n   5. **刷新页面，标签页消失** : 打开了几个标签页后，再刷新页面，发现标签页都消失了。原因是标签页的数据没有被存储起来，就好像登录模块中，登录后需要存储 `token` 令牌一样\n\n5. ####  填充 Footer 页脚\n\n   1. **添加页脚样式布局** : 后台管理页面骨架还差最后一块拼图：***Footer 页脚***。因为页脚只涉及样式布局，并没有任何的 `js` 功能代码，所以非常简单。\n   2. 最终效果，如下图所示，可以看到只是一些版权信息的展示, 用于上线之后放置备案信息![image-20241029170144337](./assets/image-20241029170144337.png)\n\n### 文章分类模块开发\n\n1. #### 分类模块接口分析\n\n   1. **分类新增接口** : 当我们进入分类管理页面，点击新增按钮时，可以新增博客文章归属的分类，如下图所示：![image-20241030152717202](./assets/image-20241030152717202.png)\n\n   2. **分类数据分页接口** : 能够查询出博客分类的分页数据，支持按条件搜索，如按分类名称的模糊查询、按创建时间段查询。如图所示:\n\n      ![image-20241030152751130](./assets/image-20241030152751130.png)\n\n   3. **分类删除接口** : 能够根据自己的需要，删除指定的分类：![image-20241030152823287](./assets/image-20241030152823287.png)\n\n   4. **获取所有分类数据的下拉列表接口** : 这个接口主要在博客发布的时候需要，当想添加新的文章时，需要勾选该文章所属的分类：本章节中用不到此接口，我们先分析出来,后续再补充功能\n\n2. #### 新增接口开发\n\n   1. **添加分类表** : 分类表设计如图所示:\n\n      ![image-20241030153438983](./assets/image-20241030153438983.png)\n\n   2. **添加表对应的 DO 类** : 在 `weblog-module-common` 模块中的 `/domain/dos` 包下，创建 `CategoryDO` 实体类，字段与表中字段一一对应;\n\n   3. **新建 `mapper`** : 在 `/domain/mapper` 包下，创建 `CategoryMapper` 接口;\n\n   4. **添加入参 `VO` 实体类** : 在`weblog-module-admin` 子模块，在 `vo` 包下，新增 `category` 包;\n\n   5. **添加分类 service 业务类** : 在 `/service/impl` 包下，创建此接口的实现类 `AdminCategoryServiceImpl`\n\n   6. **添加 controller** : 在 `/controller` 包下，创建 `AdminCategoryController` 分类控制器\n\n3. #### 分页接口开发\n\n   1. **分页查询简述**  :  分页查询就是把**需要查询的数据集进行分批展示**，比如商品表中有 1万 条手机数据，每页按固定数量展示。分页接口允许客户端应用程序从服务器端获取数据的一个部分（即一页），而不是一次性获取所有数据。\n\n   2. **分页接口关键参数：**\n\n      1. **页码（Page Number）**：表示用户希望获取的页数。通常从第一页开始递增，用户可以选择跳转到不同的页码以获取不同的数据集。\n      2. **每页数据数量（Page Size）**：表示每一页包含的数据记录数量。用户可以设置每页显示多少条数据，这个值通常由用户自行选择或者由应用程序默认设定。\n      3. **总记录数（Total Records）**：表示整个数据集中的总数据记录数量。这个值通常用于计算总共有多少页数据可供分页使用。\n\n   3. **分页接口的好处 :** \n\n      1. **性能优化**：对于大型数据集，一次性加载全部数据可能会导致网络请求变得非常慢，消耗大量的带宽和服务器资源。分页可以降低单次请求的数据量，提高数据的加载速度和性能。\n      2. **用户体验**：分页允许用户在大数据集中浏览数据，而不会被一大堆数据淹没。用户可以根据自己的需求轻松浏览不同页的数据，提供了更好的用户体验。\n      3. **服务器资源管理**：分页可以帮助服务器更好地管理资源。服务器只需提供客户端请求的那一部分数据，而不需要一次性加载整个数据集，从而减轻了服务器的负担。\n      4. **数据传输成本**：对于移动应用或者有限带宽的网络环境，减少一次性传输的数据量可以降低数据传输成本。\n\n   4. **开始开发分页接口** \n\n      1. **定义接口出入参 `JSON` 格式** : \n\n         1. **入参 `JSON` 格式**：\n\n            ```json\n            {\n              \"current\": 1, // 要查询的页码\n              \"size\": 10, // 每页要展示的数据量\n              \"name\": \"\", // 分类名称\n              \"startDate\": \"\", // 起始创建时间\n              \"endDate\": \"\", // 结束创建时间\n            \n            }\n            ```\n\n            ​		\n\n         2. **出参 `JSON` 格式** :\n\n         ```\n         {\n           \"success\": true,\n           \"message\": null,\n           \"errorCode\": null,\n           \"data\": [\n             {\n               \"name\": \"测试分类\",\n               \"createTime\": \"2023-09-18 12:02:31\"\n             },\n             {\n               \"name\": \"test\",\n               \"createTime\": \"2023-09-18 11:48:58\"\n             }\n           ],\n           \"total\": 4, // 总记录数\n           \"size\": 10, // 每页展示的记录数\n           \"current\": 1, // 当前页码\n           \"pages\": 1 // 总共多少页\n         }\n         ```\n\n      2. **`Mybatis Plus` 添加分页插件** :该插件可以帮助我们在 Mybatis Plus 中，方便地实现分页功能。编辑 `MybatisPlusConfig` 配置类，添加分页插件\n\n      3. 添加基本`CRUD`操作 : \n\n         1. **添加表对应的 DO 类** \n         2. **新建 `mapper`** : 在 `/domain/mapper` 包下，创建 `CategoryMapper` 接口;\n         3. **添加入参 `VO` 实体类** : 在`weblog-module-admin` 子模块，在 `vo` 包下，新增 `category` 包;\n         4. **添加分类 service 业务类** : 在 `/service/impl` 包下，创建此接口的实现类 `AdminCategoryServiceImpl`\n         5. **添加 controller** : 在 `/controller` 包下，创建 `AdminCategoryController` 分类控制器\n\n      4. ##### 模糊查询\n\n         1. 首先拿到了提交过来的查询页码、每页需要展示的数据数量两个字段，通过它们初始化了一个 `Page` 分页对象。然后，构建 `SQL` 的查询条件，包括当分类不为空时，添加名称的模糊查询；区间字段不为空时，构建 `create_time` 字段的大于等于、小于等于筛选，以及按创建时间倒叙排列。\n\n            条件构建完毕后，通过调用 `categoryMapper.selectPage()` 方法执行分页查询，分页插件会自动帮助我们执行两条 `SQL` , `select count(*)` 用于查询记录总数，若有数据，则执行 `limit` 分页语句\n\n         2. ```java\n                @Autowired\n                private CategoryMapper categoryMapper;\n               \n                @Override\n                public PageResponse findCategoryList(FindCategoryPageListReqVO findCategoryPageListReqVO) {\n                    // 获取当前页、以及每页需要展示的数据数量\n                    Long current = findCategoryPageListReqVO.getCurrent();\n                    Long size = findCategoryPageListReqVO.getSize();\n            \n                    // 分页对象(查询第几页、每页多少数据)\n                    Page<CategoryDO> page = new Page<>(current, size);\n            \n                    // 构建查询条件\n                    LambdaQueryWrapper<CategoryDO> wrapper = new LambdaQueryWrapper<>();\n            \n                    String name = findCategoryPageListReqVO.getName();\n                    LocalDate startDate = findCategoryPageListReqVO.getStartDate();\n                    LocalDate endDate = findCategoryPageListReqVO.getEndDate();\n            \n                    wrapper\n                        .like(StringUtils.isNotBlank(name), CategoryDO::getName, name.trim()) // like 模块查询\n                        .ge(Objects.nonNull(startDate), CategoryDO::getCreateTime, startDate) // 大于等于 startDate\n                        .le(Objects.nonNull(endDate), CategoryDO::getCreateTime, endDate)  // 小于等于 endDate\n                        .orderByDesc(CategoryDO::getCreateTime); // 按创建时间倒叙\n            \n                    // 执行分页查询\n                    Page<CategoryDO> categoryDOPage = categoryMapper.selectPage(page, wrapper);\n            \n                    List<CategoryDO> categoryDOS = categoryDOPage.getRecords();\n            \n                    // DO 转 VO\n                    List<FindCategoryPageListRspVO> vos = null;\n                    if (!CollectionUtils.isEmpty(categoryDOS)) {\n                        vos = categoryDOS.stream()\n                                .map(categoryDO -> FindCategoryPageListRspVO.builder()\n                                        .id(categoryDO.getId())\n                                        .name(categoryDO.getName())\n                                        .createTime(categoryDO.getCreateTime())\n                                        .build())\n                                .collect(Collectors.toList());\n                    }\n            \n                    return PageResponse.success(categoryDOPage, vos);\n                }\n            \n            ```\n\n      5. ### \n\n4. #### 删除接口开发\n\n   1. 拿到了分类 ID, 然后通过 `categoryMapper` 内部封装好的 `deleteById()` 方法，直接将主键 ID 传入，执行删除 `SQL`\n\n5. #### 样式布局\n\n   1. **样式分析 :** 包含三部分:\n\n      - 顶部的分页搜索条件区域，主持按分类名称、创建时间来搜索；\n\n      - ![image-20241030162242318](./assets/image-20241030162242318.png)\n\n      - 中间的分类列表区域；\n\n      - ![image-20241030162252727](./assets/image-20241030162252727.png)\n\n      - 下方的分页区域，能够展示总数据量、每页展示多少条数据、当前页码等；\n\n      - ![image-20241030162315475](./assets/image-20241030162315475.png)\n\n   2. **添加顶部搜索** : \n\n      1. 通过 `<el-card>` [卡片组件](https://element-plus.org/zh-CN/component/card.html) 作为顶层容器，目的是为了实现一个卡片效果，同时，设置了其 `shadow=\"never\"` 属性，指定卡片没有阴影。里层我们引入了多个 Element Plus 组件，包括 `<el-text>` 文字、`<el-input>` 输入框、`<el-date-picker>` [日期选择](https://element-plus.org/zh-CN/component/date-picker.html) 多个组件，这里我讲讲 `<el-date-picker>` 日期选择组件中，用到的每个属性的意思：\n         - `type` : 日期选择类型，`daterange` 表示类型为区间选择；\n         - `range-separator` ： 选择范围时的分隔符；\n         - `start-placeholder` ： 范围选择时开始日期的占位内容；\n         - `end-placeholder` ： 范围选择时结束日期的占位内容；\n\n   3. **添加中间 Table 表格** : \n\n      1. 在顶部搜索布局下方，再新增一个卡片组件，然后在其中，添加一个新增按钮，以及 `<el-table>` 表格组件。关于表格组件，`:data` 属性用于渲染表格内数据，和变量 `tableData` 绑定到了一起，`border` 用于指定表格带边框，`stripe` 用于指定斑马纹效果。这里注意，*操作*一栏并非展示数据，而是添加了删除按钮。\n\n   4. **添加下方分页组件** : \n\n      1. 官方也提供了现成的,还是简述参数功能:\n         1. `v-model:current-page=\"current\"` : 绑定当前页码，默认为 1；\n         2. `v-model:page-size=\"size\"` : 绑定每页显示的数据量，默认为 10；\n         3. `:page-sizes=\"[10, 20, 50]\"` : 指定每页显示多少条数据，有几种选项，如每页展示 10 条；\n         4. `layout=\"total, sizes, prev, pager, next, jumper\"` ： 指定分页组件的布局顺序，小哈这里指的是：总数据量在最前，跟着每页展示多少数据，上一页，当前页，下一页，跳转到指定页。\n\n\n### 标签模块开发');
INSERT INTO `t_article_content` VALUES (7, 7, '# Tailwind CSS \n\n------\n\n\n\n## 第一章：Tailwind CSS 简介\n\n### Tailwind CSS 的起源和历史：\n\nTailwind CSS 是由Adam Wathan和Steve Schoger在2017年创建的。它最初是为了解决传统CSS框架在定制性和灵活性方面的局限性。Tailwind CSS的设计理念是提供一个高度可定制的工具集，允许开发者以实用为先的原则构建用户界面，而不是依赖于预定义的组件。\n\n### 为什么选择 Tailwind CSS：\n\n1. 高度可定制：Tailwind CSS允许开发者从零开始构建设计系统，而不是被限制在预定义的组件中。\n2. 实用为先：Tailwind CSS提供了一系列实用类，可以快速组合出各种样式，提高了开发效率。\n3. 响应式设计：Tailwind CSS内置了响应式工具，可以轻松创建适应不同屏幕尺寸的布局。\n4. 易于维护：由于Tailwind CSS的实用类是原子化的，因此代码更加清晰，易于维护和修改。\n5. 社区支持：Tailwind CSS拥有一个活跃的社区，提供了大量的资源和工具，有助于开发者学习和使用。\n\n### Tailwind CSS 的核心概念：\n\n1. 实用类（Utility Classes）：Tailwind CSS的核心是实用类，它们是预定义的CSS类，可以快速组合以创建各种样式。\n2. 响应式设计：Tailwind CSS提供了响应式实用类，可以根据不同的屏幕尺寸应用不同的样式。\n3. 配置文件：Tailwind CSS允许开发者通过配置文件自定义主题、变量和实用类。\n4. JIT（Just-In-Time）模式：Tailwind CSS的JIT模式可以动态生成实用类，减少了最终CSS文件的大小。\n\n### 与其他CSS框架的比较：\n\n1. Bootstrap：Bootstrap是一个成熟的CSS框架，提供了大量的预定义组件和样式。与Tailwind CSS相比，Bootstrap更注重组件的复用性，而Tailwind CSS更注重实用性和可定制性。\n2. Foundation：Foundation也是一个流行的CSS框架，它提供了丰富的组件和样式。与Tailwind CSS相比，Foundation更注重移动端的设计，而Tailwind CSS更注重实用性和可定制性。\n3. Material-UI：Material-UI是一个基于Google Material Design的React组件库。与Tailwind CSS相比，Material-UI更注重组件的复用性和一致性，而Tailwind CSS更注重实用性和可定制性。\n\n## 第二章：安装与配置\n\n### 安装 Tailwind CSS：\n\n要安装Tailwind CSS，你需要使用npm或yarn来添加它到你的项目中。以下是使用npm的步骤：\n\n1. 打开终端或命令提示符。\n2. 导航到你的项目目录。\n3. 运行以下命令来安装Tailwind CSS：\n\n```shell\nnpm install tailwindcss postcss autoprefixer\n```\n\n或者，如果你使用yarn：\n\n```shell\nyarn add tailwindcss postcss autoprefixer\n```\n\n安装完成后，你需要初始化Tailwind CSS。这可以通过运行以下命令来完成：\n\n```shell\nnpx tailwindcss init -p\n```\n\n这个命令会创建一个`tailwind.config.js`文件，并添加一个`postcss.config.js`文件到你的项目目录中。[cmdragon\'s Blog](https://link.segmentfault.com/?enc=IEgdzjcQ7r%2FJR8H04Tcu7Q%3D%3D.CS2i0Lpo3%2B90nh1ZjyI4CXvq055nY5dtpinFWMzbQRU%3D)\n\n### 配置 Tailwind CSS：\n\n在`tailwind.config.js`文件中，你可以自定义Tailwind CSS的配置。以下是一些常见的配置选项：\n\n1. `purge`：指定一个或多个文件路径，Tailwind CSS将只包含这些文件中使用的实用类。\n2. `darkMode`：启用或禁用暗黑模式。\n3. `extract`：将实用类提取到单独的CSS文件中。\n4. `corePlugins`：禁用或自定义核心实用类。\n\n### 使用 Tailwind CSS CLI：\n\nTailwind CSS CLI提供了一系列命令来帮助开发者管理项目。以下是一些常用的命令：\n\n1. `tailwindcss build`：构建Tailwind CSS。\n2. `tailwindcss watch`：监听文件变化并自动构建Tailwind CSS。\n3. `tailwindcss serve`：启动一个本地服务器，预览Tailwind CSS。\n\n### 在不同项目中集成 Tailwind CSS：\n\n要在不同的项目中集成Tailwind CSS，你需要在每个项目中重复上述的安装和配置步骤。Tailwind CSS是独立于框架的，因此你可以将它集成到任何使用CSS预处理器（如Sass或Less）或原生CSS的项目中。\n\n如果你正在使用React、Vue或Angular等前端框架，你可能需要安装Tailwind CSS的特定插件来更好地集成。例如，对于React，你可以使用`tailwindcss/react`：\n\n```shell\nnpm install tailwindcss/react\n```\n\n或者，如果你使用yarn：\n\n```shell\nyarn add tailwindcss/react\n```\n\n这将允许你使用Tailwind CSS的实用类来构建React组件。\n\n## 第三章：基础语法\n\n### 原子类（Utility Classes）的概念：\n\n原子类是Tailwind CSS的核心概念，它提供了一系列的预定义类，可以快速地应用到HTML元素上以实现样式。这些类是“原子”的，因为它们代表单个属性和值，如`text-blue-500`或`bg-gray-100`。使用原子类可以避免编写大量的CSS代码，并且可以快速地构建和迭代设计。\n\n### 常用原子类的使用：\n\nTailwind CSS提供了大量的原子类，涵盖了布局、颜色、字体、边距、填充、边框、阴影、动画等各个方面。以下是一些常用的原子类示例：\n\n- 文本颜色：`text-red-500`、`text-green-300`\n- 背景颜色：`bg-blue-400`、`bg-yellow-200`\n- 字体大小：`text-sm`、`text-lg`\n- 边距：`m-2`、`mt-4`（m是margin的缩写，mt是margin-top的缩写）\n- 填充：`p-3`、`pt-5`（p是padding的缩写，pt是padding-top的缩写）\n- 边框：`border`、`border-2`（边框宽度）\n- 阴影：`shadow`、`shadow-lg`\n- 布局：`flex`、`flex-wrap`、`justify-center`\n- 动画：`animate-bounce`、`animate-pulse`\n\n### 定制化原子类：\n\nTailwind CSS允许你通过配置文件`tailwind.config.js`来自定义原子类。例如，你可以添加自定义的颜色、字体、边距等。以下是一个简单的自定义示例：\n\n```javascript\nmodule.exports = {\n  theme: {\n    extend: {\n      colors: {\n        \'brand\': \'#ff69b4\', // 自定义颜色\n      },\n      spacing: {\n        \'9\': \'2.25rem\', // 自定义边距\n      }\n    }\n  }\n}\n```\n\n### 响应式设计：\n\nTailwind CSS内置了响应式设计的支持，允许你根据不同的屏幕尺寸应用不同的样式。响应式设计是通过在原子类前添加断点前缀来实现的。Tailwind CSS预定义了以下几个断点：\n\n- `sm`：小于640px\n- `md`：大于等于640px\n- `lg`：大于等于1024px\n- `xl`：大于等于1280px\n- `2xl`：大于等于1536px\n\n使用响应式设计的原子类示例如下：\n\n```xml\n<div class=\"text-sm sm:text-base lg:text-lg xl:text-xl\">响应式文本大小</div>\n<div class=\"p-4 sm:p-6 lg:p-8\">响应式边距</div>\n```\n\n在上面的例子中，文本在手机屏幕上显示为小号，在平板上显示为基础大小，在桌面显示器上显示为大号，而在大屏幕显示器上显示为超大号。边距也有类似的响应式变化。\n\n## 第四章：布局与网格系统\n\n### 使用 Tailwind CSS 进行布局：\n\nTailwind CSS 提供了一系列的原子类来帮助开发者快速构建响应式布局。这些类包括用于控制容器宽度、间距、对齐方式、显示类型等。例如，`container` 类可以用来创建一个最大宽度为 1/2 屏幕宽度的容器，`mx-auto` 类可以将元素水平居中，`flex` 类可以将子元素设置为 Flexbox 布局，等等。\n\n### 网格系统的使用：\n\nTailwind CSS 提供了一个灵活的网格系统，允许开发者通过简单的类名来创建复杂的布局。网格系统基于 12 列，可以通过 `grid-cols-*` 类来定义列数，例如 `grid-cols-3` 表示将容器分为三列。此外，还可以使用 `gap-*` 类来设置网格之间的间隔。\n\nDemo：\n\n```xml\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Tailwind CSS Grid System</title>\n    <script src=\"https://cdn.tailwindcss.com\"></script>\n</head>\n<body class=\"bg-gray-100\">\n\n<div class=\"container mx-auto p-4\">\n    <h1 class=\"text-3xl font-bold mb-4\">Grid System</h1>\n\n    <div class=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\">\n        <div class=\"p-4 bg-white rounded-lg shadow-md\">\n            <h2 class=\"text-xl font-bold\">Column 1</h2>\n            <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. Suspendisse lectus tortor, dignissim sit amet, adipiscing nec, ultricies sed, dolor.</p>\n        </div>\n\n        <div class=\"p-4 bg-white rounded-lg shadow-md\">\n            <h2 class=\"text-xl font-bold\">Column 2</h2>\n            <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. Suspendisse lectus tortor, dignissim sit amet, adipiscing nec, ultricies sed, dolor.</p>\n        </div>\n\n        <div class=\"p-4 bg-white rounded-lg shadow-md\">\n            <h2 class=\"text-xl font-bold\">Column 3</h2>\n            <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. Suspendisse lectus tortor, dignissim sit amet, adipiscing nec, ultricies sed, dolor.</p>\n        </div>\n    </div>\n</div>\n\n</body>\n</html>\n```\n\n在这个 Demo 中，我们使用了 Tailwind CSS 的 `container` 类来创建一个响应式的容器，并且使用了 `grid` 类来创建一个网格系统。`grid-cols-1` 表示列数为 1，`md:grid-cols-2` 表示在中等大小的屏幕上列数为 2，`lg:grid-cols-3` 表示在大屏幕上列数为 3。\n\n这个网格系统会根据屏幕尺寸自动调整列数，从而实现响应式布局。你可以根据需要调整 `grid-cols-*` 的值来改变列数。\n\n### Flexbox 和 Grid 布局：\n\nTailwind CSS 支持两种主要的布局方式：Flexbox 和 Grid。Flexbox 布局适用于单行或单列布局，而 Grid 布局适用于多行或多列布局。使用 Flexbox 布局时，可以通过 `flex`、`flex-row`、`flex-wrap`、`justify-between` 等类来控制子元素的布局和对齐。使用 Grid 布局时，可以通过 `grid`、`grid-cols-*`、`grid-rows-*`、`place-items-center` 等类来控制网格的布局和对齐。\n\n以下是一个使用 Tailwind CSS 的 Flexbox 和 Grid 布局的简单示例：\n\n### Flexbox 布局\n\n```xml\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Tailwind CSS Flexbox Layout</title>\n    <script src=\"https://cdn.tailwindcss.com\"></script>\n</head>\n<body class=\"bg-gray-100\">\n\n<div class=\"flex items-center justify-center h-screen\">\n    <div class=\"flex-1 bg-blue-500 p-4 text-white\">\n        Item 1\n    </div>\n    <div class=\"flex-1 bg-green-500 p-4 text-white\">\n        Item 2\n    </div>\n    <div class=\"flex-1 bg-red-500 p-4 text-white\">\n        Item 3\n    </div>\n</div>\n\n</body>\n</html>\n```\n\n在这个 Flexbox 示例中，`.flex` 类用于创建一个 Flexbox 容器，`.items-center` 和 `.justify-center` 类用于将子元素居中。`.h-screen` 类确保容器的高度等于视口的高度。\n\n### Grid 布局\n\n```xml\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Tailwind CSS Grid Layout</title>\n    <script src=\"https://cdn.tailwindcss.com\"></script>\n</head>\n<body class=\"bg-gray-100\">\n\n<div class=\"grid grid-cols-3 gap-4\">\n    <div class=\"bg-blue-500 p-4 text-white\">\n        Item 1\n    </div>\n    <div class=\"bg-green-500 p-4 text-white\">\n        Item 2\n    </div>\n    <div class=\"bg-red-500 p-4 text-white\">\n        Item 3\n    </div>\n</div>\n\n</body>\n</html>\n```\n\n在这个 Grid 布局示例中，`.grid` 类用于创建一个 Grid 容器，`.grid-cols-3` 类用于设置容器有三个列，`.gap-4` 类用于设置列之间的间隔为 4 像素。\n\n### 布局组件和模式：\n\nTailwind CSS 提供了一系列的布局组件和模式，可以帮助开发者快速构建常见的布局结构。例如，`card` 类可以用来创建卡片组件，`nav` 类可以用来创建导航栏，`dropdown` 类可以用来创建下拉菜单，等等。这些组件和模式都是通过组合不同的原子类来实现的，可以轻松地定制和扩展。\n\n以下是一个简单的布局示例，结合了 Flexbox 和 Grid 布局：\n\n```xml\n<div class=\"container mx-auto p-4\">\n  <div class=\"flex justify-between\">\n    <div class=\"w-1/2\">\n      <div class=\"card bg-white shadow-lg p-6\">\n        <h2 class=\"text-2xl font-bold mb-4\">标题</h2>\n        <p class=\"text-gray-700\">内容</p>\n      </div>\n    </div>\n    <div class=\"w-1/2\">\n      <div class=\"grid grid-cols-3 gap-4\">\n        <div class=\"bg-blue-500 p-4\">网格项 1</div>\n        <div class=\"bg-green-500 p-4\">网格项 2</div>\n        <div class=\"bg-red-500 p-4\">网格项 3</div>\n      </div>\n    </div>\n  </div>\n</div>\n```\n\n在这个示例中，我们创建了一个包含两个子元素的 Flexbox 布局，其中一个子元素是一个卡片组件，另一个子元素是一个三列的 Grid 布局。通过组合不同的原子类，我们可以快速构建出复杂的布局结构。\n\n## 第五章：样式与设计\n\n### 文本样式：\n\n在 Tailwind CSS 中，文本样式可以通过一系列的原子类来控制，包括字体大小、字体粗细、文本颜色、文本对齐、文本装饰等。例如，`text-lg` 类用于设置文本大小为较大，`font-bold` 类用于设置文本粗细为加粗，`text-gray-800` 类用于设置文本颜色为深灰色，`text-center` 类用于设置文本居中对齐，`underline` 类用于添加下划线。\n\n以下是一个简单的 HTML 示例，展示了如何使用 Tailwind CSS 的文本样式类：\n\n```xml\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Tailwind CSS Text Styles</title>\n    <script src=\"https://cdn.tailwindcss.com\"></script>\n</head>\n<body class=\"bg-gray-100 p-4\">\n\n<h1 class=\"text-3xl font-bold text-gray-800\">标题</h1>\n<p class=\"text-lg text-gray-600\">这是一个段落，使用了 <span class=\"text-sm text-red-500\">不同大小和颜色的文本</span>。</p>\n<p class=\"text-base text-gray-500 text-center\">这是一个居中对齐的段落。</p>\n<p class=\"text-sm text-gray-400 line-through\">这是一个带有删除线的段落。</p>\n<p class=\"text-xs font-bold text-green-500 underline\">这是一个带有下划线的加粗小号文本。</p>\n\n</body>\n</html>\n```\n\n在这个示例中，我们使用了以下 Tailwind CSS 文本样式类：\n\n- `text-3xl`: 设置标题的字体大小为 3 倍大。\n- `font-bold`: 设置标题的字体粗细为加粗。\n- `text-gray-800`: 设置标题的文本颜色为深灰色。\n- `text-lg`: 设置段落的字体大小为较大。\n- `text-gray-600`: 设置段落的文本颜色为灰色。\n- `text-base`: 设置段落的字体大小为默认大小。\n- `text-gray-500`: 设置段落的文本颜色为灰色。\n- `text-center`: 设置段落的文本居中对齐。\n- `text-sm`: 设置段落的字体大小为小号。\n- `text-gray-400`: 设置段落的文本颜色为浅灰色。\n- `line-through`: 添加删除线到段落文本。\n- `text-xs`: 设置段落的字体大小为非常小。\n- `font-bold`: 设置段落的字体粗细为加粗。\n- `text-green-500`: 设置段落的文本颜色为绿色。\n- `underline`: 添加下划线到段落文本。\n\n这些类可以组合使用，以创建各种文本样式。通过调整类名，你可以轻松地改变文本的外观，而不需要编写任何自定义 CSS。\n\n### 背景与边框：\n\n背景和边框样式也可以通过原子类来控制。例如，`bg-red-500` 类用于设置背景颜色为红色，`border` 类用于添加边框，`border-gray-300` 类用于设置边框颜色为浅灰色，`rounded` 类用于设置边框圆角。\n\n### 颜色与阴影：\n\nTailwind CSS 提供了一系列的颜色类和阴影类。颜色类基于 Tailwind CSS 的颜色系统，可以用于设置文本、背景、边框等颜色。阴影类可以用于添加阴影效果，例如 `shadow` 类用于添加默认阴影，`shadow-lg` 类用于添加较大的阴影。\n\n以下是一个简单的 HTML 示例，展示了如何使用 Tailwind CSS 的背景和边框样式类：\nAD：[覆盖广泛主题工具可供使用](https://link.segmentfault.com/?enc=9hcZ4m3QcAIOYsdItoFLgg%3D%3D.d8sIBEnh62PeeHDd%2F88zRPIpuyg3sJDPdDe%2FA2UUKjo%3D)\n\n```xml\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Tailwind CSS Background and Border Styles</title>\n    <script src=\"https://cdn.tailwindcss.com\"></script>\n</head>\n<body class=\"bg-gray-100 p-4\">\n\n<div class=\"bg-red-500 p-4 rounded-lg\">\n    <p class=\"text-white\">这是一个背景为红色的方块，边框圆角为 8px。</p>\n</div>\n\n<div class=\"border border-gray-300 p-4 rounded-lg\">\n    <p class=\"text-gray-700\">这是一个带有浅灰色边框的方块，边框圆角为 8px。</p>\n</div>\n\n<div class=\"bg-blue-500 border border-blue-700 p-4 rounded-lg\">\n    <p class=\"text-white\">这是一个背景和边框颜色都为蓝色的方块，边框圆角为 8px。</p>\n</div>\n\n</body>\n</html>\n```\n\n在这个示例中，我们使用了以下 Tailwind CSS 背景和边框样式类：\n\n- `bg-red-500`: 设置元素的背景颜色为红色。\n- `p-4`: 设置元素的 padding 为 4px。\n- `rounded-lg`: 设置元素的边框圆角为 8px。\n- `border`: 添加边框到元素。\n- `border-gray-300`: 设置元素的边框颜色为浅灰色。\n- `border-blue-700`: 设置元素的边框颜色为深蓝色。\n\n这些类可以组合使用，以创建各种背景和边框样式。通过调整类名，你可以轻松地改变元素的外观，而不需要编写任何自定义 CSS。\n\n### 交互样式：\n\n交互样式用于控制用户与元素交互时的样式，例如鼠标悬停、焦点等。Tailwind CSS 提供了一系列的交互类，例如 `hover:bg-blue-500` 类用于在鼠标悬停时改变背景颜色，`focus:outline-none` 类用于在元素获得焦点时去除轮廓。\n\n以下是一个简单的样式示例，结合了文本样式、背景与边框、颜色与阴影、交互样式：\n\n```xml\n<div class=\"container mx-auto p-4\">\n  <h1 class=\"text-4xl font-bold text-center text-gray-800 mb-8\">标题</h1>\n  <div class=\"bg-white shadow-lg p-6 rounded\">\n    <p class=\"text-gray-700\">内容</p>\n    <button class=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded mt-4\">\n      按钮\n    </button>\n  </div>\n</div>\n```\n\n在这个示例中，我们创建了一个包含标题和内容的布局。标题使用了大号字体、加粗、居中对齐和深灰色文本。内容部分使用了白色背景、阴影、圆角和内边距。按钮使用了蓝色背景、鼠标悬停时变为深蓝色、白色文本、加粗、内边距和圆角。通过组合不同的原子类，我们可以快速构建出具有丰富样式的界面。\n\n下面是一个更完整的示例，展示了 Tailwind CSS 中不同交互状态下的样式变化，包括悬停、焦点、激活和禁用状态。\n\n```xml\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Tailwind CSS Interactions</title>\n    <script src=\"https://cdn.tailwindcss.com\"></script>\n</head>\n<body class=\"bg-gray-100\">\n\n<div class=\"flex justify-center items-center mt-10\">\n    <button class=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\">\n        Hover Me\n    </button>\n</div>\n\n<div class=\"flex justify-center items-center mt-10\">\n    <button class=\"bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50\">\n        Click Me\n    </button>\n</div>\n\n<div class=\"flex justify-center items-center mt-10\">\n    <button class=\"bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50\">\n        Focus Me\n    </button>\n</div>\n\n<div class=\"flex justify-center items-center mt-10\">\n    <button class=\"bg-yellow-500 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded active:bg-yellow-800 active:scale-95\">\n        Active Me\n    </button>\n</div>\n\n<div class=\"flex justify-center items-center mt-10\">\n    <button class=\"bg-purple-500 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded opacity-50 cursor-not-allowed\" disabled>\n        Disabled\n    </button>\n</div>\n\n</body>\n</html>\n```\n\n在这个示例中，我们使用了以下 Tailwind CSS 交互样式类：\n\n- `hover:bg-blue-700`: 当鼠标悬停在元素上时，背景颜色变为深蓝色。\n- `focus:outline-none`: 当元素获得焦点时，移除默认的焦点轮廓。\n- `focus:ring-2`: 当元素获得焦点时，添加一个 2px 的环形边框。\n- `focus:ring-red-500`: 当元素获得焦点时，环形边框的颜色为红色。\n- `focus:ring-opacity-50`: 当元素获得焦点时，环形边框的不透明度为 50%。\n- `active:bg-yellow-800`: 当元素被激活时，背景颜色变为深黄色。\n- `active:scale-95`: 当元素被激活时，元素的大小缩小到 95%。\n- `opacity-50`: 设置元素的透明度为 50%。\n- `cursor-not-allowed`: 设置鼠标悬停在元素上时的光标为禁止符号。\n- `disabled`: 禁用按钮，使其不可点击。\n\n这个示例展示了如何使用 Tailwind CSS 来创建具有不同交互状态的按钮。你可以根据需要调整颜色、边框、透明度等样式。\n\n## 第六章：组件与复用\n\n### 创建可复用的组件：\n\n在 Tailwind CSS 中，创建可复用的组件通常涉及将一组样式类应用于一个 HTML 元素，并将该元素保存为一个自定义组件。这可以通过创建一个 HTML 结构，并使用 Tailwind CSS 的原子类来定义其样式来实现。例如，创建一个按钮组件：\n\n```xml\n<!-- Button Component -->\n<button class=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\">\n  Click me\n</button>\n```\n\n以下是一个简单的 Vue 组件示例，展示如何创建一个可复用的按钮组件。\n\n首先，创建一个名为 `Button.vue` 的组件文件：\n\n```xml\n<!-- Button.vue -->\n<template>\n  <button :class=\"`bg-${color}-500 text-white font-bold py-2 px-4 rounded ${className}`\" :style=\"{ fontSize: size + \'px\' }\">\n    {{ text }}\n  </button>\n</template>\n\n<script>\nexport default {\n  props: {\n    text: {\n      type: String,\n      required: true\n    },\n    color: {\n      type: String,\n      required: true\n    },\n    size: {\n      type: Number,\n      required: true\n    },\n    className: {\n      type: String,\n      default: \'\'\n    }\n  }\n}\n</script>\n```\n\n在这个组件中，我们定义了以下 props：\n\n- `text`: 按钮的文本内容。\n- `color`: 按钮的背景颜色。\n- `size`: 按钮的字体大小。\n- `className`: 额外的类名，可以用来覆盖或添加样式。\n\n现在，你可以在你的 Vue 应用中使用这个组件：\n\n```xml\n<!-- App.vue -->\n<template>\n  <div>\n    <h1 class=\"text-3xl font-bold mb-4\">Welcome to My App!</h1>\n    <Button text=\"Large Blue Button\" color=\"blue\" size=\"18\" />\n    <Button text=\"Small Green Button\" color=\"green\" size=\"14\" />\n    <Button text=\"Medium Red Button\" color=\"red\" size=\"16\" />\n  </div>\n</template>\n\n<script>\nimport Button from \'./Button.vue\';\n\nexport default {\n  components: {\n    Button\n  }\n}\n</script>\n```\n\n在这个例子中，我们创建了一个 `Button` 组件，它接受文本、颜色、大小和额外的类名作为 props，并返回一个带有相应样式的按钮。然后，我们在 `App.vue` 中使用了这个组件，并传递了不同的文本、颜色和大小值来创建不同样式的按钮。\n\n### 使用组件库：\n\nTailwind UI 是一个官方的 Tailwind CSS 组件库，它提供了大量的预设计组件，可以帮助开发者快速构建界面。要使用 Tailwind UI，你需要购买订阅并下载组件库。一旦你有了组件库，你可以将其集成到你的项目中，并按照文档中的说明来使用组件。\n\n以下是如何在 Vue 项目中使用 Tailwind UI 组件的一个基本示例：\n\n1. **下载 Tailwind UI 组件库**：首先，你需要从 Tailwind UI 网站下载组件库。这通常涉及到购买订阅并下载一个包含所有组件的 ZIP 文件。\n2. **集成到项目中**：将下载的组件库解压，并将 HTML、Vue 或 React 组件文件复制到你的项目中。\n3. **使用组件**：在你的 Vue 组件中，你可以直接导入并使用 Tailwind UI 提供的组件。\n\n例如，如果你想要使用 Tailwind UI 提供的按钮组件，你可以在你的 Vue 组件中这样做：\n\n```xml\n<!-- MyButton.vue -->\n<template>\n  <div>\n    <!-- 使用 Tailwind UI 的按钮组件 -->\n    <button class=\"tw-button tw-button--primary\">\n      Click me!\n    </button>\n  </div>\n</template>\n\n<script>\n// 假设你已经将 Tailwind UI 的按钮组件复制到了你的项目中\nimport Button from \'./path/to/tailwind-ui/components/button.vue\';\n\nexport default {\n  components: {\n    \'tw-button\': Button\n  }\n}\n</script>\n```\n\n在这个例子中，我们假设你已经将 Tailwind UI 的按钮组件复制到了你的项目中，并且将其重命名为 `button.vue`。然后，我们在 Vue 组件中导入了这个按钮组件，并在模板中使用它。\n\n请注意，上面的代码只是一个示例，实际的 Tailwind UI 组件可能会有不同的命名和导入方式，具体取决于你下载的组件库版本和你的项目结构。\n\n由于 Tailwind UI 是一个付费产品，我无法提供实际的组件代码。但是，一旦你有了 Tailwind UI 组件库，你可以按照其文档中的说明来使用和定制组件。\n\n### 组件状态和变体：\n\n组件状态和变体是 Tailwind CSS 的一个强大功能，它允许你根据组件的不同状态（如悬停、焦点、活动等）或变体（如大小、颜色等）来应用不同的样式。例如，你可以创建一个按钮组件，它在悬停时改变背景颜色：\n\n```xml\n<!-- Button with hover state -->\n<button class=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\">\n  Click me\n</button>\n```\n\n在这个例子中，`hover:bg-blue-700` 是一个状态变体，它指定了按钮在鼠标悬停时的背景颜色。Tailwind CSS 还支持其他状态变体，如 `focus:outline-none`（焦点时去除轮廓）和 `active:bg-blue-800`（活动时改变背景颜色）。\n\n通过使用组件状态和变体，你可以创建出更加动态和响应式的用户界面。\n\n## 第七章：响应式设计\n\n### 响应式设计原则：\n\n响应式设计是一种使网页能够自适应不同设备和屏幕尺寸的设计方法。其核心原则包括：\n\n1. 流体网格：使用相对单位（如百分比）而不是固定单位（如像素）来定义布局，使页面元素能够根据屏幕尺寸调整大小。\n2. 弹性图片和媒体：确保图片和其他媒体元素能够根据容器的大小进行缩放，避免溢出。\n3. 媒体查询：使用 CSS 媒体查询来应用不同的样式规则，以适应不同的视口宽度。\n4. 移动优先：从移动设备的设计开始，然后逐步添加样式以适应更大的屏幕，确保移动用户的体验优先。\n\n### 媒体查询的使用：\n\n媒体查询是 CSS3 的一个功能，允许开发者根据设备的特性（如视口宽度、高度、方向等）应用不同的样式。在 Tailwind CSS 中，你可以直接在类中使用媒体查询，例如：\n\n```xml\n<div class=\"p-4 sm:p-6 md:p-8\">\n  <!-- 内容 -->\n</div>\n```\n\n在这个例子中，`p-4` 表示在小于 `sm`（640px）的屏幕上应用 1rem（默认 16px）的内边距，`sm:p-6` 表示在 `sm` 屏幕上应用 1.5rem 的内边距，`md:p-8` 表示在 `md`（768px）及以上屏幕上应用 2rem 的内边距。\n\n### 响应式实用类：\n\nTailwind CSS 提供了一系列响应式实用类，这些类允许你根据不同的断点应用不同的样式。这些类以 `sm:`、`md:`、`lg:`、`xl:` 和 `2xl:` 前缀表示不同的屏幕尺寸断点。例如：\n\n```xml\n<div class=\"hidden sm:block\">\n  <!-- 在小于 sm 断点的屏幕上隐藏，在 sm 及以上屏幕上显示 -->\n</div>\n```\n\n### 移动优先设计：\n\n移动优先设计是一种设计策略，它从最小的屏幕尺寸开始设计，然后逐步添加样式以适应更大的屏幕。在 Tailwind CSS 中，这通常意味着首先定义移动设备的样式，然后使用响应式实用类来覆盖或添加样式以适应更大的屏幕。例如：\n\n```xml\n<button class=\"bg-blue-500 text-white py-2 px-4 rounded md:bg-red-500\">\n  <!-- 在移动设备上背景为蓝色，在 md 及以上屏幕上背景为红色 -->\n</button>\n```\n\n通过遵循响应式设计原则，使用媒体查询和响应式实用类，以及采用移动优先的设计策略，你可以创建出适应各种设备和屏幕尺寸的网页。\n\n## 第八章：高级功能\n\n### 定制化配置：\n\n定制化配置是指根据项目需求对开发工具或框架进行个性化设置。以 Tailwind CSS 为例，你可以通过修改 `tailwind.config.js` 文件来定制化配置。例如，你可以添加自定义颜色、字体、边框、阴影等。以下是一个简单的配置示例：\n\n```javascript\nmodule.exports = {\n  theme: {\n    extend: {\n      colors: {\n        primary: \'#3490dc\',\n        secondary: \'#ffed4a\',\n        danger: \'#e3342f\',\n      },\n      spacing: {\n        \'128\': \'32rem\',\n      },\n    },\n  },\n  variants: {\n    extend: {},\n  },\n  plugins: [],\n};\n```\n\n在这个配置中，我们添加了自定义颜色和间距。\n\n### 插件系统：\n\n插件系统允许开发者扩展和定制工具或框架的功能。以 Tailwind CSS 为例，你可以创建自定义插件来添加新的实用类或修改现有实用类的行为。以下是一个简单的插件示例：\n\n```javascript\nmodule.exports = function ({ addBase, theme }) {\n  addBase({\n    \'.my-custom-class\': {\n      color: theme(\'colors.primary\'),\n      padding: theme(\'spacing.4\'),\n    },\n  });\n};\n```\n\n在这个插件中，我们添加了一个名为 `.my-custom-class` 的新实用类。\n\n### JavaScript 集成：\n\nJavaScript 集成是指将 JavaScript 代码与 CSS 样式相结合，以实现更复杂的功能。以 Tailwind CSS 为例，你可以使用 JavaScript 来动态地添加或移除实用类。以下是一个简单的示例：\n\n```javascript\ndocument.addEventListener(\'DOMContentLoaded\', () => {\n  const button = document.querySelector(\'#my-button\');\n  button.addEventListener(\'click\', () => {\n    button.classList.add(\'bg-blue-500\', \'text-white\', \'py-2\', \'px-4\', \'rounded\');\n  });\n});\n```\n\n在这个示例中，当用户点击按钮时，按钮的样式会动态地改变。\n\n### 性能优化：\n\n性能优化是指提高网页的加载速度和运行效率。以下是一些性能优化的方法：\n\n1. 压缩和合并 CSS 和 JavaScript 文件。\n2. 使用图片优化工具来减小图片文件大小。\n3. 利用浏览器缓存来存储静态资源。\n4. 使用懒加载技术来延迟加载非关键资源。\n5. 确保代码的效率和可维护性。\n\n通过定制化配置、使用插件系统、JavaScript 集成和性能优化，你可以创建出更强大、更灵活和更高效的网页。\n\n## 附录\n\n### 常见问题解答：\n\n1. **什么是 Tailwind CSS？**\n   - Tailwind CSS 是一个功能类优先的 CSS 框架，它允许你通过组合类来快速构建自定义用户界面。\n2. **为什么选择 Tailwind CSS？**\n   - 快速开发：通过组合类快速构建 UI。\n   - 定制性强：可以轻松定制和扩展。\n   - 响应式设计：内置响应式工具类，方便实现不同屏幕尺寸的适配。\n3. **如何安装 Tailwind CSS？**\n   - 使用 npm 或 yarn 安装 Tailwind CSS。\n   - 在你的 CSS 文件中引入 Tailwind CSS。\n4. **Tailwind CSS 如何与 JavaScript 框架集成？**\n   - Tailwind CSS 可以与 React、Vue、Angular 等框架集成。\n   - 按照框架的文档进行配置和集成。\n\n### 资源与工具：\n\n1. **Tailwind CSS 官方文档**：提供详细的指南和 API 参考。\n2. **Tailwind CSS UI Kit**：提供预制的 UI 组件，可以快速启动项目。\n3. **Tailwind CSS Play**：在线工具，可以实时预览和测试 Tailwind CSS 类。\n4. **Tailwind CSS Plugins**：社区提供的插件，扩展 Tailwind CSS 的功能。\n\n### 学习路径与进阶：\n\n1. **基础阶段**：学习 Tailwind CSS 的核心概念和类。\n2. **进阶阶段**：学习如何自定义 Tailwind CSS，包括主题配置和插件开发。\n3. **高级阶段**：学习如何将 Tailwind CSS 集成到 JavaScript 框架中，以及如何进行性能优化。\n4. **专业领域**：根据项目需求，学习 Tailwind CSS 在不同领域的应用，如电子商务、内容管理、数据分析等。\n5. **持续学习**：关注 Tailwind CSS 的更新和社区动态，学习新的功能和最佳实践。\n\n### 相关示例代码\n\nbutton\n\n```xml\n<button class=\"cursor-pointer group relative flex gap-1.5 px-8 py-4 bg-black bg-opacity-80 text-[#f1f1f1] rounded-3xl hover:bg-opacity-70 transition font-semibold shadow-md\">\n  <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"24px\" width=\"24px\"><g stroke-width=\"0\" id=\"SVGRepo_bgCarrier\"></g><g stroke-linejoin=\"round\" stroke-linecap=\"round\" id=\"SVGRepo_tracerCarrier\"></g><g id=\"SVGRepo_iconCarrier\"> <g id=\"Interface / Download\"> <path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"2\" stroke=\"#f1f1f1\" d=\"M6 21H18M12 3V17M12 17L17 12M12 17L7 12\" id=\"Vector\"></path> </g> </g></svg>\n  Download\n  <div class=\"absolute opacity-0 -bottom-full rounded-md py-2 px-2 bg-black bg-opacity-70 left-1/2 -translate-x-1/2 group-hover:opacity-100 transition-opacity shadow-lg\">\n    Download\n  </div>\n</button>\n```\n\ncheckbox\n\n```xml\n<input\n  type=\"checkbox\"\n  id=\"react-option\"\n  value=\"\"\n  class=\"hidden peer\"\n  required=\"\"\n/>\n\n<label\n  for=\"react-option\"\n  class=\"flex z-10 items-center peer relative justify-center w-14 h-14 shadow-lg duration-300 [box-shadow:1px_1px_0px_1px_#eab92d] border-2 border-gray-800 peer-checked:border-2 peer-checked:border-gray-800 rounded-lg cursor-pointer text-neutral-50 peer-checked:[box-shadow:1px_1px_0px_1px_#075985] peer-checked:hover:[box-shadow:1px_1px_0px_1px_#1e1e1e] hover:[box-shadow:1px_1px_0px_1px_#1e1e1e]\"\n>\n</label>\n<svg\n  class=\"absolute stroke-sky-800 w-12 h-23 duration-300 peer-checked:opacity-100 opacity-0\"\n  height=\"100\"\n  preserveAspectRatio=\"xMidYMid meet\"\n  viewBox=\"0 0 100 100\"\n  width=\"100\"\n  x=\"0\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n  y=\"0\"\n>\n  <path\n    class=\"svg-stroke-primary\"\n    d=\"M82.1,61.2a31.9,31.9,0,0,1-12.4,2.4A33.3,33.3,0,0,1,36.4,30.3a31.9,31.9,0,0,1,2.4-12.4A33.3,33.3,0,1,0,82.1,61.2Z\"\n    fill=\"none\"\n    stroke-linecap=\"round\"\n    stroke-linejoin=\"round\"\n    stroke-width=\"8\"\n  ></path>\n</svg>\n<svg\n  class=\"absolute stroke-yellow-500 w-12 h-23 duration-300 peer-checked:opacity-0 opacity-100\"\n  height=\"100\"\n  preserveAspectRatio=\"xMidYMid meet\"\n  viewBox=\"0 0 100 100\"\n  width=\"100\"\n  x=\"0\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n  y=\"0\"\n>\n  <path\n    class=\"svg-stroke-primary\"\n    d=\"M50,18v3.6m0,56.8V82M82,50H78.4M21.6,50H18M72.6,72.6l-2.5-2.5M29.9,29.9l-2.5-2.5m45.2,0-2.5,2.5M29.9,70.1l-2.5,2.5M64.2,50A14.2,14.2,0,1,1,50,35.8,14.3,14.3,0,0,1,64.2,50Z\"\n    fill=\"none\"\n    stroke-linecap=\"round\"\n    stroke-linejoin=\"round\"\n    stroke-width=\"8\"\n  ></path>\n</svg>\n```\n\nToggle switch\n\n```xml\n<label class=\"relative inline-flex items-center cursor-pointer\">\n  <input class=\"sr-only peer\" value=\"\" type=\"checkbox\" />\n  <div\n    class=\"w-24 h-12 rounded-full ring-0 peer duration-500 outline-none bg-gray-200 overflow-hidden before:flex before:items-center before:justify-center after:flex after:items-center after:justify-center before:content-[\'☀️\'] before:absolute before:h-10 before:w-10 before:top-1/2 before:bg-white before:rounded-full before:left-1 before:-translate-y-1/2 before:transition-all before:duration-700 peer-checked:before:opacity-0 peer-checked:before:rotate-90 peer-checked:before:-translate-y-full shadow-lg shadow-gray-400 peer-checked:shadow-lg peer-checked:shadow-gray-700 peer-checked:bg-[#383838] after:content-[\'🌑\'] after:absolute after:bg-[#1d1d1d] after:rounded-full after:top-[4px] after:right-1 after:translate-y-full after:w-10 after:h-10 after:opacity-0 after:transition-all after:duration-700 peer-checked:after:opacity-100 peer-checked:after:rotate-180 peer-checked:after:translate-y-0\"\n  ></div>\n</label>\n```\n\ncard\n\n```xml\n<div class=\"relative flex w-80 flex-col rounded-xl bg-white bg-clip-border text-gray-700 shadow-md\">\n  <div class=\"relative mx-4 -mt-6 h-40 overflow-hidden rounded-xl bg-blue-gray-500 bg-clip-border text-white shadow-lg shadow-blue-gray-500/40 bg-gradient-to-r from-blue-500 to-blue-600\">\n  </div>\n  <div class=\"p-6\">\n    <h5 class=\"mb-2 block font-sans text-xl font-semibold leading-snug tracking-normal text-blue-gray-900 antialiased\">\n     Tailwind card\n    </h5>\n    <p class=\"block font-sans text-base font-light leading-relaxed text-inherit antialiased\">\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc felis ligula. \n    </p>\n  </div>\n  <div class=\"p-6 pt-0\">\n    <button data-ripple-light=\"true\" type=\"button\" class=\"select-none rounded-lg bg-blue-500 py-3 px-6 text-center align-middle font-sans text-xs font-bold uppercase text-white shadow-md shadow-blue-500/20 transition-all hover:shadow-lg hover:shadow-blue-500/40 focus:opacity-[0.85] focus:shadow-none active:opacity-[0.85] active:shadow-none disabled:pointer-events-none disabled:opacity-50 disabled:shadow-none\">\n      Read More\n    </button>\n  </div>\n</div>\n```\n\n## 速查\n\n### 布局和宽高\n\n- `w-{size}`: 设置宽度（例如：`w-1/2` 设置宽度为父元素的一半）。\n- `h-{size}`: 设置高度（例如：`h-64` 设置高度为64px）。\n- `min-w-{size}`: 设置最小宽度。\n- `max-w-{size}`: 设置最大宽度。\n- `min-h-{size}`: 设置最小高度。\n- `max-h-{size}`: 设置最大高度。\n\n### 间距（Padding 和 Margin）\n\n- `p-{size}`: 设置内边距（padding）。\n- `m-{size}`: 设置外边距（margin）。\n- `pt-{size}`: 设置顶部内边距。\n- `mt-{size}`: 设置顶部外边距。\n- `px-{size}`: 设置左右内边距。\n- `mx-{size}`: 设置左右外边距。\n\n### flexbox 和 grid\n\n- `flex`: 设置 `display: flex`。\n\n- `flex-{direction}`: 设置 flex 方向（例如：`flex-row`）。\n\n- `justify-{justify}`: 设置 flexbox 主轴对齐方式（例如：`justify-center`）。\n\n- `items-{align}`: 设置 flexbox 交叉轴对齐方式（例如：`items-center`）。\n\n- ##### 主轴（Main Axis）\n\n  主轴是 flex 容器的主要布局方向。flex 项（flex children）沿着主轴被放置。主轴的方向可以通过 `flex-direction` 属性来设置，以下是 `flex-direction` 的可能值：\n\n  - `row`（默认值）：主轴是水平的，从左到右。\n  - `row-reverse`：主轴是水平的，从右到左。\n  - `column`：主轴是垂直的，从上到下。\n  - `column-reverse`：主轴是垂直的，从下到上。\n\n  在主轴上，可以使用以下属性来对齐 flex 项：\n\n  - `justify-content`：定义了 flex 项在主轴上的对齐方式（例如，`justify-content: center;` 将 flex 项居中对齐）。\n  - `justify-items`：定义了 flex 项的单独对齐方式。\n  - `justify-self`：定义了单个 flex 项的对齐方式。\n\n  ##### 交叉轴（Cross Axis）\n\n  交叉轴是垂直于主轴的轴。交叉轴的方向依赖于主轴的方向。例如，如果主轴是水平的（`row` 或 `row-reverse`），那么交叉轴就是垂直的；如果主轴是垂直的（`column` 或 `column-reverse`），那么交叉轴就是水平的。\n\n  在交叉轴上，可以使用以下属性来对齐 flex 项：\n\n  - `align-items`：定义了 flex 项在交叉轴上的对齐方式（例如，`align-items: center;` 将 flex 项在交叉轴上居中对齐）。\n  - `align-content`：定义了多行 flex 项之间的空间分配和对齐方式。\n  - `align-self`：定义了单个 flex 项在交叉轴上的对齐方式。\n\n- `grid`: 设置 `display: grid`。\n\n- `grid-cols-{number}`: 设置 grid 列的数量。\n\n### 定位\n\n- `static`: 设置 `position: static`。\n- `relative`: 设置 `position: relative`。\n- `absolute`: 设置 `position: absolute`。\n- `fixed`: 设置 `position: fixed`。\n- `sticky`: 设置 `position: sticky`。\n\n### 文本\n\n- `text-{size}`: 设置字体大小。\n- `font-{weight}`: 设置字体粗细。\n- `leading-{size}`: 设置行高。\n- `tracking-{size}`: 设置字母间距。\n- `text-{align}`: 设置文本对齐方式。\n\n### 背景\n\n- `bg-{color}`: 设置背景颜色。\n- `bg-{size}`: 设置背景图片尺寸。\n- `bg-{position}`: 设置背景图片位置。\n- `bg-{repeat}`: 设置背景图片重复方式。\n\n### 边框\n\n- `border`: 设置边框。\n- `border-{width}`: 设置边框宽度。\n- `border-{color}`: 设置边框颜色。\n- `rounded-{size}`: 设置边框圆角。\n\n### 响应式\n\n- `{screen}:class`: 在特定屏幕尺寸上应用类（例如：`md:text-lg` 在中等屏幕尺寸及以上时应用 `text-lg`）。\n\n### 伪类和状态\n\n- `hover:class`: 在鼠标悬停时应用类。\n- `focus:class`: 在元素聚焦时应用类。\n- `active:class`: 在元素激活时应用类。\n- `group:hover:class`: 在一组元素中，当任何一个元素被悬停时应用类。\n\n### 其他\n\n- `opacity-{number}`: 设置透明度。\n- `transition-{property}`: 设置过渡效果。\n- `transform-{transform}`: 设置变换效果。\n  这些只是一小部分 Tailwind CSS 提供的类。Tailwind CSS 的文档非常全面，提供了所有可用类的详细列表和用法示例。');
INSERT INTO `t_article_content` VALUES (8, 8, '请输入内容#### animate__bounce\n\n- **介绍**：使元素产生弹跳效果。\n\n##### 2. animate__flash\n\n- **介绍**：使元素闪烁，看起来像是快速地亮起和熄灭。\n\n##### 3. animate__pulse\n\n- **介绍**：使元素产生脉冲效果，即放大和缩小。\n\n##### 4. animate__rubberBand\n\n- **介绍**：使元素产生橡皮筋拉扯的效果。\n\n##### 5. animate__shakeX\n\n- **介绍**：使元素沿水平方向快速左右摇动。\n\n##### 6. animate__shakeY\n\n- **介绍**：使元素沿垂直方向快速上下摇动。\n\n##### 7. animate__headShake\n\n- **介绍**：模拟头部摇动的效果，通常用于表示否定或困惑。\n\n##### 8. animate__swing\n\n- **介绍**：使元素像钟摆一样来回摆动。\n\n##### 9. animate__tada\n\n- **介绍**：使元素产生一个庆祝的摇动效果。\n\n##### 10. animate__wobble\n\n- **介绍**：使元素左右轻微摇晃，模拟不稳定的效果。\n\n##### 11. animate__jello\n\n- **介绍**：使元素像果冻一样颤动。\n\n##### 12. animate__heartBeat\n\n##### **介绍**：使元素模拟心跳的效果，即放大和缩小。\n\n##### 13. animate__fadeIn\n\n- **介绍**：使元素淡入视野。\n\n##### 14. animate__fadeInDown\n\n- **介绍**：使元素从上方淡入视野。\n\n##### 15. animate__fadeInLeft\n\n- **介绍**：使元素从左侧淡入视野。\n\n##### 16. animate__fadeInRight\n\n- **介绍**：使元素从右侧淡入视野。\n\n##### 17. animate__fadeInUp\n\n- **介绍**：使元素从下方淡入视野。\n\n##### 18. animate__fadeOut\n\n- **介绍**：使元素淡出视野。\n\n##### 19. animate__fadeOutDown\n\n- **介绍**：使元素向下方淡出视野。\n\n##### 20. animate__fadeOutLeft\n\n- **介绍**：使元素向左侧淡出视野。\n\n##### 21. animate__fadeOutRight\n\n- **介绍**：使元素向右侧淡出视野。\n\n##### 22. animate__fadeOutUp\n\n- **介绍**：使元素向上方淡出视野。\n\n##### 23. animate__flip\n\n- **介绍**：使元素进行翻转。\n\n##### 24. animate__flipInX\n\n- **介绍**：使元素沿X轴翻转进入视野。\n\n##### 25. animate__flipInY\n\n- **介绍**：使元素沿Y轴翻转进入视野。\n\n##### 26. animate__flipOutX\n\n- **介绍**：使元素沿X轴翻转出视野。\n\n##### 27. animate__flipOutY\n\n- **介绍**：使元素沿Y轴翻转出视野。\n\n##### 28. animate__lightSpeedInRight\n\n- **介绍**：使元素从右侧快速进入视野。\n\n##### 29. animate__lightSpeedInLeft\n\n- **介绍**：使元素从左侧快速进入视野。\n\n##### 30. animate__lightSpeedOutRight\n\n- **介绍**：使元素向右侧快速出视野。\n\n##### 31. animate__lightSpeedOutLeft\n\n- **介绍**：使元素向左侧快速出视野。\n\n##### 32. animate__rotateIn\n\n- **介绍**：使元素旋转进入视野。\n\n##### 33. animate__rotateInDownLeft\n\n- **介绍**：使元素从左下方旋转进入视野。\n\n##### 34. animate__rotateInDownRight\n\n- **介绍**：使元素从右下方旋转进入视野。\n\n##### 35. animate__rotateInUpLeft\n\n- **介绍**：使元素从左上方旋转进入视野。\n\n##### 36. animate__rotateInUpRight\n\n- **介绍**：使元素从右上方旋转进入视野。\n\n##### 37. animate__rotateOut\n\n- **介绍**：使元素旋转出视野。\n\n##### 38. animate__rotateOutDownLeft\n\n- **介绍**：使元素向左下方旋转出视野。\n\n##### 39. animate__rotateOutDownRight\n\n- **介绍**：使元素向右下方旋转出视野。\n\n##### 40. animate__rotateOutUpLeft\n\n- **介绍**：使元素向左上方旋转出视野。\n\n##### 41. animate__rotateOutUpRight\n\n- **介绍**：使元素向右上方旋转出视野。\n\n##### 42. animate__hinge\n\n- **介绍**：使元素像门铰链一样打开。\n\n##### 43. animate__jackInTheBox\n\n- **介绍**：使元素像玩偶盒中的玩偶一样突然弹出');
INSERT INTO `t_article_content` VALUES (9, 9, '# vue常用语法\n\n### 1. 常用方法和变量\n\n#### （1）`setup` 函数\n\n`setup` 函数是Composition API的入口函数，用于定义组件的响应式变量和方法。在Vue 3中，你可以根据需要从Vue中导入特定的API，例如：\n\n```\nimport { createApp } from \'vue\';\nimport App from \'./App.vue\';\ncreateApp(App).mount(\'#app\');\n```\n\n#### （2）响应式变量\n\nVue 3通过`ref`和`reactive`两个函数来定义响应式数据。这些响应式变量在数据变化时会自动更新视图。\n\n- `ref`：用于定义基本类型的数据，如数字和字符串。例如：\n\n  ```\n  import { ref } from \'vue\';\n  const count = ref(0);\n  ```\n\n  `ref`返回一个包含`value`属性的对象，你可以通过`count.value`来访问和修改值。\n\n- `reactive`：用于定义复杂类型的数据，如对象或数组。例如：\n\n  ```\n  import { reactive } from \'vue\';\n  const state = reactive({ count: 0 });\n  ```\n\n  `reactive`使得整个对象成为响应式的，你可以直接修改对象的属性，而不需要像`ref`那样通过`.value`来访问。\n\n### 2. 监听和触发更新\n\nVue 3还允许你监听响应式变量的变化，并手动触发响应式更新。这可以通过`watch`和`watchEffect`来实现。\n\n- `watch`：允许你监视一个或多个响应式数据源，并在数据变化时执行回调函数。例如：\n\n  ```\n  import { watch } from \'vue\';\n  watch(count, (newVal, oldVal) => {\n    console.log(`count changed from ${oldVal} to${newVal}`);\n  });\n  ```\n\n- `watchEffect`：立即执行一个函数，同时响应式地追踪其依赖，并在依赖变化时重新执行。例如：\n\n  ```\n  import { watchEffect } from \'vue\';\n  watchEffect(() => {\n    console.log(count.value);\n  });\n  ```\n\n### 3. 组合式 API（Composition API）\n\nVue 3 的一个主要特点是引入了 Composition API，它提供了一种更灵活的方式来组织和重用代码。以下是一些相关的 API：\n\n- `computed`: 用于定义计算属性，这些属性会根据其依赖自动更新。\n\n  javascript\n\n  复制\n\n  ```\n  import { computed } from \'vue\';\n  const doubleCount = computed(() => count.value * 2);\n  ```\n\n- `toRefs` 和 `toRef`: 用于将响应式对象转换为单独的响应式引用，这在解构 `reactive` 对象时特别有用。\n\n  javascript\n\n  复制\n\n  ```\n  import { toRefs, reactive } from \'vue\';\n  const state = reactive({ count: 0, name: \'Vue\' });\n  const { count, name } = toRefs(state);\n  ```\n\n- `provide` 和 `inject`: 用于跨组件传递数据，无需通过props逐层传递。\n\n### 4. 生命周期钩子\n\nVue 3 中的生命周期钩子也有所更新，支持 Composition API 的用法：\n\n- `onBeforeMount`\n- `onMounted`\n- `onBeforeUpdate`\n- `onUpdated`\n- `onBeforeUnmount`\n- `onUnmounted`\n\n### 5. 组件\n\n- `defineComponent`: 用于定义组件，它使得类型推断更加友好。\n\n  javascript\n\n  复制\n\n  ```\n  import { defineComponent } from \'vue\';\n  export default defineComponent({\n    // 组件选项\n  });\n  ```\n\n- `h`: 用于创建虚拟节点（VNodes），通常在`render`函数中使用。\n\n### 6. v-model 更新\n\nVue 3 中 `v-model` 的用法有所更新，支持对组件的多个模型绑定，并且可以自定义 `v-model` 的修饰符。\n\n### 7. 全局 API 和配置\n\n- `globalProperties`: 用于添加全局属性，这些属性可以在所有组件实例中访问。\n\n### 8. 性能优化\n\n- `teleport`: 用于将子组件渲染到DOM的另一部分，而不改变组件的逻辑结构。\n- `Suspense`: 用于等待嵌套组件渲染或异步组件加载，提供了一种处理加载状态的方式。');

-- ----------------------------
-- Table structure for t_article_tag_rel
-- ----------------------------
DROP TABLE IF EXISTS `t_article_tag_rel`;
CREATE TABLE `t_article_tag_rel`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `article_id` bigint(20) UNSIGNED NOT NULL COMMENT '文章id',
  `tag_id` bigint(20) UNSIGNED NOT NULL COMMENT '标签id',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_article_id`(`article_id`) USING BTREE,
  INDEX `idx_tag_id`(`tag_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 24 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章对应标签关联表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_article_tag_rel
-- ----------------------------
INSERT INTO `t_article_tag_rel` VALUES (10, 6, 45);
INSERT INTO `t_article_tag_rel` VALUES (11, 6, 46);
INSERT INTO `t_article_tag_rel` VALUES (15, 7, 47);
INSERT INTO `t_article_tag_rel` VALUES (16, 7, 48);
INSERT INTO `t_article_tag_rel` VALUES (17, 7, 49);
INSERT INTO `t_article_tag_rel` VALUES (18, 8, 49);
INSERT INTO `t_article_tag_rel` VALUES (19, 8, 48);
INSERT INTO `t_article_tag_rel` VALUES (20, 8, 47);
INSERT INTO `t_article_tag_rel` VALUES (21, 9, 49);
INSERT INTO `t_article_tag_rel` VALUES (22, 9, 48);
INSERT INTO `t_article_tag_rel` VALUES (23, 9, 47);

-- ----------------------------
-- Table structure for t_blog_settings
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_settings`;
CREATE TABLE `t_blog_settings`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `logo` varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '博客Logo',
  `name` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '博客名称',
  `author` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '作者名',
  `introduction` varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '介绍语',
  `avatar` varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '作者头像',
  `github_homepage` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT 'GitHub 主页访问地址',
  `csdn_homepage` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT 'CSDN 主页访问地址',
  `gitee_homepage` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT 'Gitee 主页访问地址',
  `zhihu_homepage` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '知乎主页访问地址',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '博客设置表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_blog_settings
-- ----------------------------
INSERT INTO `t_blog_settings` VALUES (1, 'https://qiccc-weblog.oss-cn-beijing.aliyuncs.com/img/%7DLSU4BW%40%28H%7DRY4%29%5DX%5DBLMDW.png', 'qiccc的博客', 'qiccc', '平安喜乐', 'https://qiccc-weblog.oss-cn-beijing.aliyuncs.com/img/%7DLSU4BW%40%28H%7DRY4%29%5DX%5DBLMDW.png', 'https://github.com/qiccc654', 'https://github.com/qiccc654', 'https://github.com/qiccc654', 'https://github.com/qiccc654');

-- ----------------------------
-- Table structure for t_category
-- ----------------------------
DROP TABLE IF EXISTS `t_category`;
CREATE TABLE `t_category`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '分类id',
  `name` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '分类名称',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '最后一次更新时间',
  `is_deleted` tinyint(2) NOT NULL DEFAULT 0 COMMENT '逻辑删除标志位：0：未删除 1：已删除',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `uk_name`(`name`) USING BTREE,
  INDEX `idx_create_time`(`create_time`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章分类表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_category
-- ----------------------------
INSERT INTO `t_category` VALUES (8, '个人', '2024-11-04 11:38:16', '2024-11-04 11:38:16', 0);
INSERT INTO `t_category` VALUES (9, '日常', '2024-11-04 11:44:43', '2024-11-04 11:44:43', 0);
INSERT INTO `t_category` VALUES (11, '学习总结', '2024-11-04 11:45:03', '2024-11-04 11:45:03', 0);
INSERT INTO `t_category` VALUES (12, '问题详解', '2024-11-04 11:45:15', '2024-11-04 11:45:15', 0);

-- ----------------------------
-- Table structure for t_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_tag`;
CREATE TABLE `t_tag`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '标签id',
  `name` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '标签名称',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '最后一次更新时间',
  `is_deleted` tinyint(2) NOT NULL DEFAULT 0 COMMENT '逻辑删除标志位：0：未删除 1：已删除',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `uk_name`(`name`) USING BTREE,
  INDEX `idx_create_time`(`create_time`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 50 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章标签表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_tag
-- ----------------------------
INSERT INTO `t_tag` VALUES (45, '博客', '2024-11-04 19:38:07', '2024-11-04 19:38:07', 0);
INSERT INTO `t_tag` VALUES (46, '个人', '2024-11-04 19:38:07', '2024-11-04 19:38:07', 0);
INSERT INTO `t_tag` VALUES (47, '快速入门', '2024-11-04 19:43:53', '2024-11-04 19:43:53', 0);
INSERT INTO `t_tag` VALUES (48, '技术', '2024-11-04 19:43:53', '2024-11-04 19:43:53', 0);
INSERT INTO `t_tag` VALUES (49, 'CSS', '2024-11-04 19:43:53', '2024-11-04 19:43:53', 0);

-- ----------------------------
-- Table structure for t_user
-- ----------------------------
DROP TABLE IF EXISTS `t_user`;
CREATE TABLE `t_user`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `username` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '用户名',
  `password` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '密码',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '最后一次更新时间',
  `is_deleted` tinyint(2) NOT NULL DEFAULT 0 COMMENT '逻辑删除：0：未删除 1：已删除',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `uk_username`(`username`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 10 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '用户表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_user
-- ----------------------------
INSERT INTO `t_user` VALUES (1, 'admin', '$2a$10$Qp66EcmduMeQC5YxOyycYOcJEQpjbDQ9VPHYykOXu.OLajdsulp.q', '2024-10-13 22:14:42', '2024-10-23 19:07:14', 0);
INSERT INTO `t_user` VALUES (9, 'test', '$2a$10$Lncm1uKIM93Z0JuxnC0Iy.3NErGT6tytGFTGF7BU9IRnlKi79V9li', '2024-10-16 19:05:08', '2024-10-21 21:10:23', 0);

-- ----------------------------
-- Table structure for t_user_role
-- ----------------------------
DROP TABLE IF EXISTS `t_user_role`;
CREATE TABLE `t_user_role`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `username` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '用户名',
  `role` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '角色',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_username`(`username`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '用户角色表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_user_role
-- ----------------------------
INSERT INTO `t_user_role` VALUES (1, 'qiccc', 'ROLE_ADMIN', '2024-10-07 01:21:15');
INSERT INTO `t_user_role` VALUES (2, 'test', 'ROLE_VISITOR', '2024-10-07 01:23:33');

SET FOREIGN_KEY_CHECKS = 1;
